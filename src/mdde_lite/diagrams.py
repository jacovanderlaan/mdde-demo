"""
MDDE Lite - Mermaid Diagram Generator

Generates Mermaid diagrams from metadata:
- ERD (Entity Relationship Diagram) from entities and relationships
- Data flow diagram from entity dependencies
- Lineage flowchart from attribute mappings

Related articles:
- "From Drawing to Generation — How Mermaid..."
- "Diagram Generation & Auto-Docs from Metadata"
- "Building the Metadata Star Generator"

This is a simplified version. The full MDDE visualizer includes:
- Interactive D3.js diagrams
- draw.io, GraphViz, yEd, PlantUML export
- VS Code integrated visualization
- Click-through navigation
"""

import duckdb
from typing import List, Dict, Optional


def generate_erd(conn: duckdb.DuckDBPyConnection, title: str = "Entity Relationship Diagram") -> str:
    """
    Generate a Mermaid ERD from entity and attribute metadata.

    Args:
        conn: Database connection with metadata
        title: Diagram title

    Returns:
        Mermaid ERD diagram as string
    """
    lines = [
        f"%% {title}",
        "%% Generated by MDDE Lite",
        "erDiagram",
    ]

    # Get all entities
    entities = conn.execute("""
        SELECT entity_id, name, entity_type
        FROM entity
        ORDER BY name
    """).fetchall()

    # Get all relationships
    relationships = conn.execute("""
        SELECT
            r.relationship_id,
            r.name,
            r.cardinality,
            se.name as source_name,
            te.name as target_name
        FROM relationship r
        JOIN entity se ON r.source_entity_id = se.entity_id
        JOIN entity te ON r.target_entity_id = te.entity_id
    """).fetchall()

    # Get attributes for each entity
    for entity_id, entity_name, entity_type in entities:
        attributes = conn.execute("""
            SELECT name, data_type, is_primary_key, is_nullable
            FROM attribute
            WHERE entity_id = ?
            ORDER BY ordinal_position
        """, [entity_id]).fetchall()

        # Entity definition
        safe_name = entity_name.upper().replace(" ", "_").replace("-", "_")
        lines.append(f"    {safe_name} {{")

        for attr_name, data_type, is_pk, is_nullable in attributes:
            # Format: type name PK/FK "comment"
            type_str = _simplify_type(data_type) if data_type else "string"
            pk_str = " PK" if is_pk else ""
            lines.append(f"        {type_str} {attr_name}{pk_str}")

        lines.append("    }")

    # Add relationships
    for rel_id, rel_name, cardinality, source_name, target_name in relationships:
        source = source_name.upper().replace(" ", "_").replace("-", "_")
        target = target_name.upper().replace(" ", "_").replace("-", "_")
        card_symbol = _cardinality_to_mermaid(cardinality)
        label = rel_name or "relates to"
        lines.append(f"    {source} {card_symbol} {target} : \"{label}\"")

    return "\n".join(lines)


def generate_dataflow(conn: duckdb.DuckDBPyConnection, title: str = "Data Flow") -> str:
    """
    Generate a Mermaid flowchart showing data flow between entities.

    Args:
        conn: Database connection with metadata
        title: Diagram title

    Returns:
        Mermaid flowchart diagram as string
    """
    lines = [
        f"%% {title}",
        "%% Generated by MDDE Lite",
        "flowchart LR",
    ]

    # Get entities grouped by layer
    entities = conn.execute("""
        SELECT entity_id, name, layer, entity_type
        FROM entity
        ORDER BY
            CASE layer
                WHEN 'source' THEN 1
                WHEN 'staging' THEN 2
                WHEN 'integration' THEN 3
                WHEN 'business' THEN 4
                ELSE 5
            END,
            name
    """).fetchall()

    # Create subgraphs by layer
    layers = {}
    for entity_id, name, layer, entity_type in entities:
        layer_name = layer or "unknown"
        if layer_name not in layers:
            layers[layer_name] = []
        layers[layer_name].append((entity_id, name, entity_type))

    # Generate subgraphs
    for layer_name, layer_entities in layers.items():
        lines.append(f"    subgraph {layer_name.upper()}")
        for entity_id, name, entity_type in layer_entities:
            safe_id = entity_id.replace("-", "_")
            shape = _get_shape(entity_type)
            lines.append(f"        {safe_id}{shape[0]}{name}{shape[1]}")
        lines.append("    end")

    # Add relationships as edges
    relationships = conn.execute("""
        SELECT
            r.source_entity_id,
            r.target_entity_id,
            r.name
        FROM relationship r
    """).fetchall()

    for source_id, target_id, name in relationships:
        source = source_id.replace("-", "_")
        target = target_id.replace("-", "_")
        label = f"|{name}|" if name else ""
        lines.append(f"    {source} -->{label} {target}")

    return "\n".join(lines)


def generate_lineage(
    conn: duckdb.DuckDBPyConnection,
    entity_id: str,
    title: str = None
) -> str:
    """
    Generate a Mermaid flowchart showing column-level lineage for an entity.

    Args:
        conn: Database connection with metadata
        entity_id: Target entity ID
        title: Optional diagram title

    Returns:
        Mermaid flowchart diagram as string
    """
    # Get entity name
    entity = conn.execute("""
        SELECT name FROM entity WHERE entity_id = ?
    """, [entity_id]).fetchone()

    if not entity:
        return f"%% Entity {entity_id} not found"

    entity_name = entity[0]
    title = title or f"Lineage for {entity_name}"

    lines = [
        f"%% {title}",
        "%% Generated by MDDE Lite",
        "flowchart LR",
    ]

    # Get attribute mappings for this entity
    mappings = conn.execute("""
        SELECT
            am.target_attribute_id,
            am.source_entity_id,
            am.source_attribute_id,
            am.mapping_type,
            am.transformation,
            ta.name as target_attr_name,
            sa.name as source_attr_name,
            se.name as source_entity_name
        FROM attribute_mapping am
        LEFT JOIN attribute ta ON am.target_attribute_id = ta.attribute_id
        LEFT JOIN attribute sa ON am.source_attribute_id = sa.attribute_id
        LEFT JOIN entity se ON am.source_entity_id = se.entity_id
        WHERE am.target_entity_id = ?
    """, [entity_id]).fetchall()

    if not mappings:
        lines.append(f"    %% No lineage data found for {entity_name}")
        return "\n".join(lines)

    # Collect unique sources
    sources = set()
    target_attrs = set()

    for mapping in mappings:
        (target_attr_id, source_entity_id, source_attr_id, mapping_type,
         transformation, target_attr_name, source_attr_name, source_entity_name) = mapping

        if source_entity_id and source_entity_name:
            sources.add((source_entity_id, source_entity_name))
        if target_attr_name:
            target_attrs.add(target_attr_name)

    # Create source nodes
    lines.append("    subgraph Sources")
    for source_id, source_name in sources:
        safe_id = source_id.replace("-", "_")
        lines.append(f"        {safe_id}[({source_name})]")
    lines.append("    end")

    # Create target node
    safe_target = entity_id.replace("-", "_")
    lines.append(f"    subgraph Target")
    lines.append(f"        {safe_target}[{entity_name}]")
    lines.append("    end")

    # Add edges with attribute info
    for mapping in mappings:
        (target_attr_id, source_entity_id, source_attr_id, mapping_type,
         transformation, target_attr_name, source_attr_name, source_entity_name) = mapping

        if source_entity_id:
            source = source_entity_id.replace("-", "_")
            target = safe_target

            # Build label
            if source_attr_name and target_attr_name:
                if mapping_type == "direct":
                    label = f"{source_attr_name}"
                elif mapping_type == "rename":
                    label = f"{source_attr_name} → {target_attr_name}"
                elif mapping_type == "derived":
                    label = f"f({source_attr_name})"
                else:
                    label = f"{source_attr_name}"
                lines.append(f"    {source} -->|{label}| {target}")
            else:
                lines.append(f"    {source} --> {target}")

    return "\n".join(lines)


def generate_all_diagrams(conn: duckdb.DuckDBPyConnection, output_dir: str = ".") -> Dict[str, str]:
    """
    Generate all diagram types and save to files.

    Args:
        conn: Database connection with metadata
        output_dir: Directory to save diagram files

    Returns:
        Dictionary mapping filename to content
    """
    from pathlib import Path

    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)

    diagrams = {}

    # Generate ERD
    erd = generate_erd(conn)
    erd_file = output_path / "erd.md"
    with open(erd_file, "w") as f:
        f.write("# Entity Relationship Diagram\n\n")
        f.write("```mermaid\n")
        f.write(erd)
        f.write("\n```\n")
    diagrams["erd.md"] = erd

    # Generate data flow
    dataflow = generate_dataflow(conn)
    flow_file = output_path / "dataflow.md"
    with open(flow_file, "w") as f:
        f.write("# Data Flow Diagram\n\n")
        f.write("```mermaid\n")
        f.write(dataflow)
        f.write("\n```\n")
    diagrams["dataflow.md"] = dataflow

    return diagrams


# ============================================================
# Helper Functions
# ============================================================


def _simplify_type(data_type: str) -> str:
    """Convert SQL data type to simple Mermaid type."""
    if not data_type:
        return "string"

    data_type = data_type.upper()

    if any(t in data_type for t in ["INT", "NUMBER", "NUMERIC", "DECIMAL"]):
        return "int"
    elif any(t in data_type for t in ["FLOAT", "DOUBLE", "REAL"]):
        return "float"
    elif any(t in data_type for t in ["BOOL"]):
        return "bool"
    elif any(t in data_type for t in ["DATE", "TIME", "TIMESTAMP"]):
        return "datetime"
    else:
        return "string"


def _cardinality_to_mermaid(cardinality: str) -> str:
    """Convert cardinality to Mermaid relationship symbol."""
    if not cardinality:
        return "||--o{"

    cardinality = cardinality.lower()

    if cardinality == "one_to_one":
        return "||--||"
    elif cardinality == "one_to_many":
        return "||--o{"
    elif cardinality == "many_to_one":
        return "}o--||"
    elif cardinality == "many_to_many":
        return "}o--o{"
    else:
        return "||--o{"


def _get_shape(entity_type: str) -> tuple:
    """Get Mermaid shape markers for entity type."""
    if not entity_type:
        return ("[", "]")

    entity_type = entity_type.lower()

    if entity_type == "table":
        return ("[", "]")  # Rectangle
    elif entity_type == "view":
        return ("([", "])") # Stadium
    elif entity_type == "cte":
        return ("((", "))")  # Circle
    else:
        return ("[", "]")


if __name__ == "__main__":
    import sys

    print("MDDE Lite - Mermaid Diagram Generator")
    print("=" * 50)

    # Demo with in-memory database
    conn = duckdb.connect(":memory:")

    # Create minimal schema
    conn.execute("""
        CREATE TABLE entity (
            entity_id VARCHAR PRIMARY KEY,
            name VARCHAR,
            entity_type VARCHAR,
            layer VARCHAR
        )
    """)
    conn.execute("""
        CREATE TABLE attribute (
            attribute_id VARCHAR PRIMARY KEY,
            entity_id VARCHAR,
            name VARCHAR,
            data_type VARCHAR,
            ordinal_position INTEGER,
            is_primary_key BOOLEAN,
            is_nullable BOOLEAN
        )
    """)
    conn.execute("""
        CREATE TABLE relationship (
            relationship_id VARCHAR PRIMARY KEY,
            name VARCHAR,
            source_entity_id VARCHAR,
            target_entity_id VARCHAR,
            cardinality VARCHAR
        )
    """)
    conn.execute("""
        CREATE TABLE attribute_mapping (
            mapping_id VARCHAR PRIMARY KEY,
            target_entity_id VARCHAR,
            target_attribute_id VARCHAR,
            source_entity_id VARCHAR,
            source_attribute_id VARCHAR,
            mapping_type VARCHAR,
            transformation VARCHAR
        )
    """)

    # Insert sample data
    conn.execute("INSERT INTO entity VALUES ('ent_customers', 'Customers', 'table', 'source')")
    conn.execute("INSERT INTO entity VALUES ('ent_orders', 'Orders', 'table', 'source')")
    conn.execute("INSERT INTO entity VALUES ('ent_order_summary', 'Order Summary', 'view', 'business')")

    conn.execute("INSERT INTO attribute VALUES ('attr_cust_id', 'ent_customers', 'customer_id', 'INTEGER', 1, true, false)")
    conn.execute("INSERT INTO attribute VALUES ('attr_cust_name', 'ent_customers', 'customer_name', 'VARCHAR', 2, false, false)")
    conn.execute("INSERT INTO attribute VALUES ('attr_ord_id', 'ent_orders', 'order_id', 'INTEGER', 1, true, false)")
    conn.execute("INSERT INTO attribute VALUES ('attr_ord_cust', 'ent_orders', 'customer_id', 'INTEGER', 2, false, false)")
    conn.execute("INSERT INTO attribute VALUES ('attr_sum_cust', 'ent_order_summary', 'customer_id', 'INTEGER', 1, true, false)")
    conn.execute("INSERT INTO attribute VALUES ('attr_sum_total', 'ent_order_summary', 'total_orders', 'INTEGER', 2, false, false)")

    conn.execute("INSERT INTO relationship VALUES ('rel_1', 'places', 'ent_customers', 'ent_orders', 'one_to_many')")
    conn.execute("INSERT INTO relationship VALUES ('rel_2', 'aggregated in', 'ent_orders', 'ent_order_summary', 'many_to_one')")

    conn.execute("INSERT INTO attribute_mapping VALUES ('map_1', 'ent_order_summary', 'attr_sum_cust', 'ent_customers', 'attr_cust_id', 'direct', NULL)")
    conn.execute("INSERT INTO attribute_mapping VALUES ('map_2', 'ent_order_summary', 'attr_sum_total', 'ent_orders', 'attr_ord_id', 'derived', 'COUNT(*)')")

    # Generate diagrams
    print("\n--- ERD ---")
    print(generate_erd(conn))

    print("\n--- Data Flow ---")
    print(generate_dataflow(conn))

    print("\n--- Lineage (Order Summary) ---")
    print(generate_lineage(conn, "ent_order_summary"))

    conn.close()
